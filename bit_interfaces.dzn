interface bit_1
{
	in void black_in();
	in void white_in();
	in void clear();
	out void empty();
	out void full();
	
	behaviour
	{
		enum bit1_state {black, white, empty};
		bit1_state state = bit1_state.empty;
		
		[state == bit1_state.empty]
		{
			on black_in: {state = bit1_state.black; full;}
			on white_in: {state = bit1_state.white; full;}
			on clear: illegal;
		}
		[state == bit1_state.black]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
		[state == bit1_state.white]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
	}
}

interface bit_2
{
	in void black_in();
	in void white_in();
	in void clear();
	out void empty();
	out void full();
	
	behaviour
	{
		enum bit1_state {black, white, empty};
		bit1_state state = bit1_state.empty;
		
		[state == bit1_state.empty]
		{
			on black_in: {state = bit1_state.black; full;}
			on white_in: {state = bit1_state.white; full;}
			on clear: illegal;
		}
		[state == bit1_state.black]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
		[state == bit1_state.white]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
	}
}

interface bit_3
{
	in void black_in();
	in void white_in();
	in void clear();
	out void empty();
	out void full();
	
	behaviour
	{
		enum bit1_state {black, white, empty};
		bit1_state state = bit1_state.empty;
		
		[state == bit1_state.empty]
		{
			on black_in: {state = bit1_state.black; full;}
			on white_in: {state = bit1_state.white; full;}
			on clear: illegal;
		}
		[state == bit1_state.black]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
		[state == bit1_state.white]
		{
			on black_in: illegal;
			on white_in: illegal;
			on clear: {state = bit1_state.empty; empty;}
		}
	}
}