interface Time
{
	out void tick();
	in void error();
	
	behaviour
	{
		enum State {single_state};
		State state = State.single_state;
		on error: state = State.single_state; // Replace by illegal if at some point you 
		on optional: tick;                    // want to catch errors specified in components
											  // rather than on interfaces...
	}
}

interface ITape //our tape of the Turing machine with 4 slots
{
	in void moveLeft(); 
	in void moveRight(); 
	out void stopTape(); //the tape has reached the correct position for changing a bit
	behaviour
	{
		enum State {stopped, moving};
		State state = State.stopped;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
  		[state.moving] on optional: {stopTape; state = State.stopped;}
	}
	
}

interface IHead //the read/write head of the Turing machine
{
  	in bool bitDetect(); //check what bit is in position
  	in bool tapeStopped(); //check if belt is moving or stopped
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on bitDetect: reply (true);
  	on bitDetect: reply (false); 
  	on tapeStopped(): reply (false);
  	on tapeStopped(): reply (true);
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  }
}

interface ILCD //LCD screen
{
  	in void getValue();
  	out void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	[state.single_state] on optional: {showValue; state = State.single_state;}
  }
}

component ICountingMachine 
{
	provides Time time_provided;
	requires Time time_required;
	provides IHead head;
	provides ITape tape;
	provides ILCD lcd;
	
	behaviour
	{
		enum State {empty, white_block, black_block, moving, stopping};
		State state = State.empty;
		[state.moving || state.stopping]
		{
			on head.bitDetect():time_required.error();//don't detect bits while tape is changing position
			on head.tapeStopped():reply(false);	//no tape is not stopped
			on head.pull():time_required.error(); //please not while tape is moving
			on head.push():time_required.error(); //please not while tape is moving
		}
		[state.empty]
		{
			on head.bitDetect():time_required.error();//no bit
			on head.tapeStopped():reply(true);
			on head.pull(): {state = State.black_block || State.white_block;} //non-deterministic?
			on head.push():time_required.error();
		}
		[state.black_block]
		{
			on head.bitDetect(): reply (false);
			on head.tapeStopped(): reply (true);
			on head.pull(): {time_required.error(); state = State.black_block;}
			on head.push(): state = State.empty;	
		}
		[state.white_block]
		{
			on head.bitDetect(): reply (true);
			on head.tapeStopped(): reply (true);
			on head.pull(): {time_required.error(); state = State.white_block;}
			on head.push(): state = State.empty;	
		}		 				 		 				 
		on tape.moveLeft(): state = State.moving;
		on tape.moveRight(): state = State.moving;
		on time_provided.error(): time_required.error();
		}
		
}

interface OutputPin 
{
  enum State {High,Low,Undefined};
  	
  in void pin_high();
  in void pin_low();

  behaviour
  {
  	State state = State.Undefined;
  	
  	on pin_high: state = State.High;
  	on pin_low: state = State.Low;
  }
}

interface InputPin 
{
  in bool read_pin();   

  behaviour
  {
    on read_pin: reply (true);
    on read_pin: reply (false);
  }
}