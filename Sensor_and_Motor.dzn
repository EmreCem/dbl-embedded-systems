interface Time
{
	in void error();
	out void tick();
	
	behaviour
	{
		enum State {single_state};
		State state = State.single_state;
		on error: state = State.single_state; // Replace by illegal if at some point you 
		on optional: tick;                   // want to catch errors specified in components
											  // rather than on interfaces...
	}
}

interface ITape //our tape of the Turing machine with 3 slots
{
	in void moveLeft(); //goes one bit position to left 
	in void moveRight(); //goes one bit position to right
	out void positionIn1(); //The tape is in position to intake into bit position 1
	out void positionIn2(); //The tape is in position to intake into bit position 2
	out void positionIn3(); //The tape is in position to intake into bit position 3
	out void positionOut1(); //The tape is in position to remove from bit position 1
	out void positionOut2();//The tape is in position to remove from bit position 2
	out void positionOut3();//The tape is in position to remove from bit position 3
	behaviour
	{
		enum State {init, correctPosition, moving, wrongPosition};
		State state = State.init;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
  		[state.moving] on optional: {stopTape; state = State.stopped;}
	}
	
}

interface IHead //the read/write head of the Turing machine
{
  	in bool bitDetect(); //check what bit is in position
  	in bool tapeStopped(); //check if belt is moving or stopped
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
   	on bitDetect: reply (true);
  	on bitDetect: reply (false); 
  	on tapeStopped: reply (false);
  	on tapeStopped: reply (true);
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  }
}

interface ILCD //LCD screen
{
  	in void getValue();
  	out void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	[state.single_state] on optional: {showValue; state = State.single_state;}
  }
}

component ICountingMachine 
{
	provides Time time_provided;
	requires Time time_required;
	provides IHead head;
	provides ITape tape;
	provides ILCD lcd;
	
	behaviour
	{
		enum State {empty, white_block, black_block, moving, stopping};
		State state = State.empty;
		[state.moving || state.stopping]
		{
			on head.bitDetect():time_required.error();//don't detect bits while tape is changing position
			on head.tapeStopped():reply(false);	//no tape is not stopped
			on head.pull():time_required.error(); //please not while tape is moving
			on head.push():time_required.error(); //please not while tape is moving
		}
		[state.empty] //state is empty
		{
			on head.bitDetect():time_required.error();//no bit so nothing to detect
			on head.tapeStopped():reply(true); //tape doesn't move when slot is empty
			on head.pull(): {state = State.black_block;} //non-deterministic?
			on head.push():time_required.error(); //can't push anything while there is nothing to push
		}
		[state.black_block]
		{
			on head.bitDetect(): reply (false);
			on head.tapeStopped(): reply (true);
			on head.pull(): {time_required.error(); state = State.black_block;}
			on head.push(): state = State.empty;	
		}
		[state.white_block]
		{
			on head.bitDetect(): reply (true);
			on head.tapeStopped(): reply (true);
			on head.pull(): {time_required.error(); state = State.white_block;}
			on head.push(): state = State.empty;	
		}		 				 		 				 
		on tape.moveLeft(): state = State.moving;
		on tape.moveRight(): state = State.moving;
		on time_provided.error(): time_required.error();
		}
		
}

interface OutputPin 
{
  enum State {High,Low,Undefined};
  	
  in void pin_high();
  in void pin_low();

  behaviour
  {
  	State state = State.Undefined;
  	
  	on pin_high: state = State.High;
  	on pin_low: state = State.Low;
  }
}

interface InputPin 
{
  in bool read_pin();   

  behaviour
  {
    on read_pin: reply (true);
    on read_pin: reply (false);
  }
}