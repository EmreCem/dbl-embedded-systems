import bit_interfaces.dzn;

interface Time
{
	in void error();
	out void tick();
	
	behaviour
	{
		enum State {single_state};
		State state = State.single_state;
		on error: state = State.single_state; // Replace by illegal if at some point you 
		on optional: tick;                   // want to catch errors specified in components
											  // rather than on interfaces...
	}
}

interface ITape //our tape of the Turing machine with 3 slots
{
	in void moveLeft(); //goes one bit position to left 
	in void moveRight(); //goes one bit position to right
	in void dontMove(); //do not move 
	out void tapeStopped(); //belt is moving or stopped
	out void positionIn(); //The tape is in position to intake bit;
	out void positionOut(); //The tape is in position to output bit;
	behaviour
	{
		enum State {init, correctPosition, moving, wrongPosition};
		State state = State.init;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
	}
	
}

interface IHead //the read/write head of the Turing machine
{
	in void checkSequence();
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	out void sequence();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  	on checkSequence: state = State.single_state;
  }
}

interface ILCD //LCD screen
{
  	in void getValue();
  	out void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	[state.single_state] on optional: {showValue; state = State.single_state;}
  }
}

interface IFloorPicker //component that picks from factory floor
{
	in void pushBlack(); //push the first black disk you come by
	in void pushWhite(); //push the first white disk you come by
	in void letPass(); //let all bits pass
	behaviour
	{
		enum State {blackRequestedInPosition, whiteRequestedInPosition, wait};
		State state = State.wait;
		[state.blackRequestedInPosition] {
			on pushBlack: state = State.wait;
			}
		[state.whiteRequestedInPosition] {
			on pushWhite: state = State.wait;
			}
	}
}
component FloorPicker
{
	provides Time time_provided;
	requires Time time_required;
	provides IFloorPicker floorPicker;
	requires ITape tape;
	requires IHead head;
	requires IBit_1 bit_1;
	requires IBit_2 bit_2;
	requires IBit_3 bit_3;
	behaviour 
	{
		enum State {waiting, picking};
		State state = State.waiting;
		[state.waiting]
		{
			on floorPicker.letPass(): {state = State.waiting;}
			on tape.tapeStopped(), tape.positionIn(): {tape.dontMove(); state = State.picking;}
		}
		[state.picking]
		{
			on floorPicker.pushBlack(): {state = State.waiting;}
			on floorPicker.pushWhite(): {state = State.waiting;}
			on bit_1.full(), bit_2.full(), bit_3.full(): {time_required.error(); state = State.waiting;} //if all bits are full, error
		}
	}
	
}

component CountingMachineHead
{
	provides IHead head;
	requires IFloorPicker floorPicker;
	
}

component CountingMachineTape 
{
	provides Time time_provided;
	requires Time time_required;
	requires IHead head;
	requires IFloorPicker floorPicker;
	provides ITape tape;
	provides ILCD lcd;
	provides IBit_1 bit_1;
	provides IBit_2 bit_2;
	provides IBit_3 bit_3;
	
	
	behaviour
	{
		enum State {init, incrementing};
		State state = State.init;
		[state.init] //initial move, waiting to fill every bit with white before anything
		{
			on tape.moveLeft(): state = State.init;
			on tape.moveRight(): state = State.init;
			on tape.positionIn(): floorPicker.pushWhite();
			on bit_1.white_in(), bit_2.white_in(), bit_3.white_in(): {
				state = State.incrementing;
			}
		}
		[state.incrementing] // can start incrementing the represented value
		{
			
			on bit_1.clear(), tape.positionOut(): {head.push(); state = State.incrementing;}
			on bit_2.clear(), tape.positionOut(): {head.push(); state = State.incrementing;}
			on bit_3.clear(), tape.positionOut(): {head.push(); state = State.incrementing;}
			on bit_1.black_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on bit_2.black_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on bit_3.black_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on bit_1.white_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on bit_2.white_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on bit_3.white_in(), tape.positionIn(): {head.pull(); state = State.incrementing;}
			on tape.moveLeft(): state = State.incrementing;
			on tape.moveRight(): state = State.incrementing;
		}		 				 		 				 
		on time_provided.error(): time_required.error();
		
		on time_required.tick():
	   {
			[state.init] time_provided.tick();
			[state.incrementing] time_provided.tick();		 
		}
		
		}
}

interface OutputPin 
{
  enum State {High,Low,Undefined};
  	
  in void pin_high();
  in void pin_low();

  behaviour
  {
  	State state = State.Undefined;
  	
  	on pin_high: state = State.High;
  	on pin_low: state = State.Low;
  }
}

interface InputPin 
{
  in bool read_pin();   

  behaviour
  {
    on read_pin: reply (true);
    on read_pin: reply (false);
  }
}
