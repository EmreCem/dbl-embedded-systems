import bit_interfaces.dzn;

interface Communication //used to be time, communication interface now. Because these will be functions of communication with mqtt
{
	in void error();
	in void tick();
	in void errorProcedure();
	
	behaviour
	{
		enum State {heartbeat, error};
		State state = State.heartbeat;
		on error: state = State.error;
		[state.heartbeat]  
		{
			on tick:{}
		}        
		[state.error]
		{
			on errorProcedure:{state = State.heartbeat;}
		}
		
	}
}

interface ITape //our tape of the Turing machine with 3 slots
{
	in void moveLeft(); //goes one bit position to left 
	in void moveRight(); //goes one bit position to right
	in void dontMove(); //do not move 
	out void tapeStopped(); //belt is moving or stopped
	out void positionIn(); //The tape is in position to intake bit;
	out void positionOut(); //The tape is in position to output bit;
	behaviour
	{
		enum State {moving, stopping};
		State state = State.stopping;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
  		on dontMove: state = State.stopping;
	}
	
}

/* interface IHeadSensor //Sensor on Tape
 {
	
	in void checkSequence();
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	out void sequence();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  	on checkSequence: state = State.single_state;
  }
}
* 
*/
interface ITapeColorSensor //Sensor on Tape
{
	out void colorSensed(); //empty, white or black
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on colorSensed: state = State.single_state;
  }
} 


interface IDiskSensor
{
	in void diskSensed();
	out void diskColor();
	behaviour
	{
	enum State {noDisk, diskPresent};
	State state = State.noDisk;
	on diskSensed(): state = State.diskPresent;
	[state.diskPresent]
	{
		diskColor; //check the color when disk is present
	}
	}
}

interface ITapePusher
{
	in void push();
	out void pushComplete();
	behaviour
	{
		enum State {waiting, pushing};
		State state = State.waiting;
		on push(): state = State.pushing;
		[state.pushing]
		{
			on pushComplete(): state = State.waiting;
		}
	}
}

interface ILCD //LCD screen
{
  	in void getValue();
  	in void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	on showValue: state = State.single_state;
  }
}
/* 
interface IFloorPicker //component that picks from factory floor
{
	in void pushBlack(); //push the first black disk you come by
	in void pushWhite(); //push the first white disk you come by
	in void letPass(); //let all bits pass
	behaviour
	{
		enum State {blackRequestedInPosition, whiteRequestedInPosition, wait};
		State state = State.wait;
		[state.blackRequestedInPosition] {
			on pushBlack: state = State.wait;
			}
		[state.whiteRequestedInPosition] {
			on pushWhite: state = State.wait;
			}
	}
}
* 
*/
interface IFloorSensor
{
	in void diskSensed();
	out void diskColor();
	behaviour
	{
	enum State {noDisk, diskPresent};
	State state = State.noDisk;
	on diskSensed(): state = State.diskPresent;
	[state.diskPresent]
	{
		diskColor; //check the color when disk is present
	}
	}
}

interface IFloorPusher
{
	in void push();
	out void completedPushProcedure();
	behaviour 
	{
		enum State {letPass, pushProcedure};
		State state = State.letPass;
		on push: state = State.pushProcedure;
		[state.pushProcedure] 
		{
			on completedPushProcedure: state = State.letPass;
		}
	}
}


component FloorPicker
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	provides IFloorPicker floorPicker;
	requires ITape tape;
	requires IHead head;
	requires IBit_1 bit_1;
	requires IBit_2 bit_2;
	requires IBit_3 bit_3;
	behaviour 
	{
		enum State {waiting, picking};
		State state = State.waiting;
		[state.waiting]
		{
			on floorPicker.letPass(): {state = State.waiting;}
			on tape.tapeStopped(), tape.positionIn(): {tape.dontMove(); state = State.picking;}
		}
		[state.picking]
		{
			on floorPicker.pushBlack(): {state = State.waiting;}
			on floorPicker.pushWhite(): {state = State.waiting;}
			on bit_1.full(), bit_2.full(), bit_3.full(): {Communication_required.error(); head.checkSequence() ;state = State.waiting;} //if all bits are full, error and check sequence
		}
	}
	
}

component CountingMachineHead
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	provides IHead head;
	requires IFloorPicker floorPicker;
	requires ITape tape;
	behaviour 
	{
		enum State {scanning, notScanning};
		State state = State.notScanning;
		[state.notScanning]
		{
			on head.checkSequence(): {head.sequence(); state = State.scanning;}
			on head.pull(): {floorPicker.pushBlack(); state = State.notScanning;}
			on head.pull(): {floorPicker.pushWhite(); state = State.notScanning;}
		}
		[state.scanning]
		{
			on head.pull(): {Communication_required.error();}
			on head.push(): {Communication_required.error();}
		}
	}
	
	
}

component CountingMachineTape 
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	requires IHead head;
	requires IFloorPicker floorPicker;
	provides ITape tape;
	provides IBit_1 bit_1;
	provides IBit_2 bit_2;
	provides IBit_3 bit_3;
	behaviour
	{
		enum State {moving, stopped};
		State state = State.stopped;
		[state.stopped]
		{
			on tape.moveLeft(), tape.moveRight(): state = State.moving;
		}
		[state.moving]
		{
			on tape.dontMove(): state = State.stopped;
		}
	}
		
}

interface IController
{
	out void incrementValue();
	out void representValue();
	behaviour 
	{
	enum State {init, incrementing, pausing};
		State state = State.init;
	on incrementValue: state = State.incrementing;
	on representValue: state = State.pausing;
	}
}
component Controller 
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	provides IController controller;
	behaviour {}
}


component System //I cant
{
	
	
	system
	{
		FloorPicker FloorPicker;
		CountingMachineHead Head;
		CountingMachineTape Tape;
		Controller controller;
	
		FloorPicker.Communication_provided <=> controller.Communication_required;
		FloorPicker.Communication_required <=> controller.Communication_provided;
		Head.Communication_provided <=> controller.Communication_required;
		Head.tape <=> Tape.tape;
		Tape.head <=> Head.head;
		Tape.floorPicker <=> FloorPicker.floorPicker;
		FloorPicker.head <=> Head.head;
		FloorPicker.tape <=> Tape.tape;
		FloorPicker.bit_1 <=> Tape.bit_1;
		FloorPicker.bit_2 <=> Tape.bit_2;
		FloorPicker.bit_3 <=> Tape.bit_3;
		Head.floorPicker <=> FloorPicker.floorPicker;
	}	
	}



