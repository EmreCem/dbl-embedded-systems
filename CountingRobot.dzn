import bit_interfaces.dzn;

interface Communication //used to be time, communication interface now. Because these will be functions of communication with mqtt
{
	in void error();
	out void tick();
	
	behaviour
	{
		enum State {single_state};
		State state = State.single_state;
		on error: state = State.single_state; 
		on optional: tick;                   
	}
}

interface ITape //our tape of the Turing machine with 3 slots
{
	in void moveLeft(); //goes one bit position to left 
	in void moveRight(); //goes one bit position to right
	in void dontMove(); //do not move 
	out void tapeStopped(); //belt is moving or stopped
	out void positionIn(); //The tape is in position to intake bit;
	out void positionOut(); //The tape is in position to output bit;
	behaviour
	{
		enum State {moving, stopping};
		State state = State.stopping;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
  		on dontMove: state = State.stopping;
	}
	
}

interface IHead //the read/write head of the Turing machine
{
	in void checkSequence();
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	out void sequence();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  	on checkSequence: state = State.single_state;
  }
}

interface ILCD //LCD screen
{
  	in void getValue();
  	out void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	[state.single_state] on optional: {showValue; state = State.single_state;}
  }
}

interface IFloorPicker //component that picks from factory floor
{
	in void pushBlack(); //push the first black disk you come by
	in void pushWhite(); //push the first white disk you come by
	in void letPass(); //let all bits pass
	behaviour
	{
		enum State {blackRequestedInPosition, whiteRequestedInPosition, wait};
		State state = State.wait;
		[state.blackRequestedInPosition] {
			on pushBlack: state = State.wait;
			}
		[state.whiteRequestedInPosition] {
			on pushWhite: state = State.wait;
			}
	}
}
component FloorPicker
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	provides IFloorPicker floorPicker;
	requires ITape tape;
	requires IHead head;
	requires IBit_1 bit_1;
	requires IBit_2 bit_2;
	requires IBit_3 bit_3;
	behaviour 
	{
		enum State {waiting, picking};
		State state = State.waiting;
		[state.waiting]
		{
			on floorPicker.letPass(): {state = State.waiting;}
			on tape.tapeStopped(), tape.positionIn(): {tape.dontMove(); state = State.picking;}
		}
		[state.picking]
		{
			on floorPicker.pushBlack(): {state = State.waiting;}
			on floorPicker.pushWhite(): {state = State.waiting;}
			on bit_1.full(), bit_2.full(), bit_3.full(): {Communication_required.error(); head.checkSequence() ;state = State.waiting;} //if all bits are full, error and check sequence
		}
	}
	
}

component CountingMachineHead
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	provides IHead head;
	requires IFloorPicker floorPicker;
	requires ITape tape;
	behaviour 
	{
		enum State {scanning, notScanning};
		State state = State.notScanning;
		[state.notScanning]
		{
			on head.checkSequence(): {head.sequence(); state = State.scanning;}
			on head.pull(): {floorPicker.pushBlack(); state = State.notScanning;}
			on head.pull(): {floorPicker.pushWhite(); state = State.notScanning;}
		}
		[state.scanning]
		{
			on head.pull(): {Communication_required.error();}
			on head.push(): {Communication_required.error();}
		}
	}
	
	
}

component CountingMachineTape 
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	requires IHead head;
	requires IFloorPicker floorPicker;
	provides ITape tape;
	provides IBit_1 bit_1;
	provides IBit_2 bit_2;
	provides IBit_3 bit_3;
	behaviour
	{
		enum State {moving, stopped};
		State state = State.stopped;
		[state.stopped]
		{
			on tape.moveLeft(), tape.moveRight(): state = State.moving;
		}
		[state.moving]
		{
			on tape.dontMove(): state = State.stopped;
		}
	}
		
}

interface IController
{
	in void incrementValue();
	in void representValue();
	out void value();
	behaviour 
	{
	enum State {init, incrementing, pausing};
		State state = State.init;
	on incrementValue: state = State.incrementing;
		on representValue: state = State.pausing;
	}
}
component Controller 
{
	provides Communication Communication_provided;
	requires Communication Communication_required;
	behaviour {}
}


component System //I cant
{
	
	
	system
	{
		
		FloorPicker FloorPicker;
		CountingMachineHead Head;
		CountingMachineTape Tape;
		Controller controller;
	
		FloorPicker.Communication_provided <=> controller.Communication_required;
		FloorPicker.Communication_required <=> controller.Communication_provided;
		Head.Communication_provided <=> controller.Communication_required;
		Head.Communication_required <=> controller.Communication_provided;
		Tape.Communication_provided <=> controller.Communication_required;
		Tape.Communication_required <=> controller.Communication_provided;
		Head.tape <=> Tape.tape;
		Tape.head <=> Head.head;
		Tape.floorPicker <=> FloorPicker.floorPicker;
		FloorPicker.head <=> Head.head;
		FloorPicker.tape <=> Tape.tape;
		FloorPicker.bit_1 <=> Tape.bit_1;
		FloorPicker.bit_2 <=> Tape.bit_2;
		FloorPicker.bit_3 <=> Tape.bit_3;
		Head.floorPicker <=> FloorPicker.floorPicker;
	}	
	}



