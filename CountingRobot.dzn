import bit_interfaces.dzn;

interface Communication //used to be time, communication interface now. Because these will be functions of communication with mqtt
{
	in void error();
	in void tick();
	in void errorProcedure();
	
	behaviour
	{
		enum State {heartbeat, error};
		State state = State.heartbeat;
		on error: state = State.error;
		[state.heartbeat]  
		{
			on tick:{}
		}        
		[state.error]
		{
			on errorProcedure:{state = State.heartbeat;}
		}
		
	}
}

interface ITape //our tape of the Turing machine with 3 slots
{
	in void moveLeft(); //goes one bit position to left 
	in void moveRight(); //goes one bit position to right
	in void dontMove(); //do not move 
	out void tapeStopped(); //belt is moving or stopped
	out void positionIn(); //The tape is in position to intake bit;
	out void positionOut(); //The tape is in position to output bit;
	behaviour
	{
		enum State {moving, stopping};
		State state = State.stopping;
		on moveLeft: state = State.moving;
  		on moveRight: state = State.moving;
  		on dontMove: state = State.stopping;
	}
	
}

/* interface IHeadSensor //Sensor on Tape
 {
	
	in void checkSequence();
  	in void push(); //take a certain bit into this position
  	in void pull(); //remove the bit from this position
  	out void sequence();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on push: state = State.single_state;
  	on pull: state = State.single_state;
  	on checkSequence: state = State.single_state;
  }
}
* 
*/
interface ITapeColorSensor //Sensor on Tape
{
	in void getColor();
	out void colorSensed(); //empty, white or black
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on colorSensed: state = State.single_state;
  }
} 


interface IDiskSensor
{
	in void diskSensed();
	out void diskColor();
	behaviour
	{
	enum State {noDisk, diskPresent};
	State state = State.noDisk;
	on diskSensed(): state = State.diskPresent;
	[state.diskPresent]
	{
		diskColor; //check the color when disk is present
	}
	}
}

interface ITapePusher
{
	in void push();
	out void pushComplete();
	behaviour
	{
		enum State {waiting, pushing};
		State state = State.waiting;
		on push(): state = State.pushing;
		[state.pushing]
		{
			on pushComplete(): state = State.waiting;
		}
	}
}

interface ILCD //LCD screen
{
  	in void getValue();
  	in void showValue();
  	behaviour
  {
  	enum State {single_state};
  	State state = State.single_state;
  	on getValue: state = State.single_state;
  	on showValue: state = State.single_state;
  }
}
/* 
interface IFloorPicker //component that picks from factory floor
{
	in void pushBlack(); //push the first black disk you come by
	in void pushWhite(); //push the first white disk you come by
	in void letPass(); //let all bits pass
	behaviour
	{
		enum State {blackRequestedInPosition, whiteRequestedInPosition, wait};
		State state = State.wait;
		[state.blackRequestedInPosition] {
			on pushBlack: state = State.wait;
			}
		[state.whiteRequestedInPosition] {
			on pushWhite: state = State.wait;
			}
	}
}
* 
*/
interface IFloorSensor
{
	in void diskSensed();
	out void diskColor();
	behaviour
	{
	enum State {noDisk, diskPresent};
	State state = State.noDisk;
	on diskSensed(): state = State.diskPresent;
	[state.diskPresent]
	{
		diskColor; //check the color when disk is present
	}
	}
}

interface IHead
{
	in void goPos1();
	behaviour
	{
		
	}
}

interface IFloorPusher
{
	in void push();
	out void completedPushProcedure();
	behaviour 
	{
		enum State {letPass, pushProcedure};
		State state = State.letPass;
		on push: state = State.pushProcedure;
		[state.pushProcedure] 
		{
			on completedPushProcedure: state = State.letPass;
		}
	}
}

component FloorPicker
{
	provides IFloorSensor iFloorSensor;
	provides IFloorPusher iFloorPusher;
	behaviour 
	{
		
	}
	
}

component Head
{
	provides IHead iHead;
	requires ITapePusher iTapePusher;
	requires ITapeColorSensor iTapeColorSensor;
	requires IDiskSensor iDiskSensor;
	requires IController iController;
	requires ITape iTape;
	behaviour 
	{
		
	}
}

component LCD 
{
	provides ILCD iLCD;
	behaviour
	{	
	}
}

component Tape 
{
	provides ITape iTape;
	behaviour
	{
	}
		
}

interface IController
{
	in void init();
	out void increment();
	in void update();
	in void error();
	// bits need white or black 
	// and can be filled or empty
	behaviour{
	enum bit_state {white, black, none};
	bit_state bit_1;
	bit_state bit_2;
	bit_state bit_3;
	}	
}

component Controller 
{
	provides IController iController;
	requires ITape itape;
	requires ILCD iLCD;
	requires ITapePusher iTapePusher;
	requires ITapeColorSensor iTapeColorSensor;
	requires IDiskSensor iDiskSensor;
	requires IFloorSensor iFloorSensor;
	requires IFloorPusher iFloorPusher;
	requires IHead iHead;
	behaviour 
	{
		
	}
}

component TapePusher
{
	provides ITapePusher iTapePusher;
	behaviour
	{
		
	}
}
component TapeColorSensor
{
	provides ITapeColorSensor iTapeColorSensor;
	behaviour
	{
		
	}
}

component DiskSensor
{
	provides IDiskSensor iDiskSensor;
	behaviour
	{
		
	}
}


component System 
{
	provides IController iController;
	
	system
	{
		Controller controller;
		Tape tape;
		LCD lcd;
		Head head;
		FloorPicker floorpicker;
		TapePusher tapepusher;
		TapeColorSensor tapecolorsensor;
		DiskSensor disksensor;
		
		iController<=>controller.iController;
		controller.iHead <=> head.iHead;
		controller.iLCD<=>lcd.iLCD;
		controller.itape<=>tape.iTape;
		controller.iFloorPusher<=>floorpicker.iFloorPusher;
		controller.iFloorSensor<=>floorpicker.iFloorSensor;
		head.iController<=>controller.iController;
		head.iDiskSensor <=> disksensor.iDiskSensor;
		head.iTape <=> tape.iTape;
		head.iTapePusher <=> tapepusher.iTapePusher;
		head.iTapeColorSensor <=> tapecolorsensor.iTapeColorSensor;
	}	
	}



